from typing import List, Dict
from ..instruction import opcodeSizeDict, opcodeNameDict

class Assembler:
    def __init__(self, inpstr: str) -> None:
        """
        Initialization method for the Assembler class.

        :param inpstr: The input string containing the assembly code.
        :return: None
        """

        # List to store input code lines
        self._inpCodeList: List[str] = []

        # Split inpstr by newline character, except in strings (marked by double quotes)
        i = 0
        s = ''
        while i < len(inpstr):
            # Check if the current character is the beginning of a string
            if inpstr[i] == '"':
                i += 1
                s += '"'
                # Collect characters until the end of the string
                while inpstr[i] != '"':
                    s += inpstr[i]
                    i += 1
            
            s += inpstr[i]
            
            # Check if the current character is a newline character
            if inpstr[i] == '\n':
                # Append the line to the input code list
                self._inpCodeList.append(s)
                s = ""

            i += 1

        # List to store output code lines
        self._outputCodeList: List[int] = []

        # Dictionary to store function names and their corresponding addresses
        self._fnDict: Dict[str, int] = dict()
        self._fnCount = 0

        # Dictionary to store labels and their corresponding addresses
        self._labelsDict: Dict[str, int] = dict()

    def getBytecodeList(self) -> List[int]:
        """
        Method to retrieve the bytecode list after processing the input code.

        :return: List[int] - The list of integers representing the bytecode.
        """
        # Initialize the code generation process
        self._initCode()

        # Resolve labels in the input code
        self._resolveLabels()

        # Create the constant pool
        self._makeConstantPool()

        # Generate the final bytecode
        self._makeCode()

        # Return the generated bytecode list
        return self._outputCodeList


    def _emit(self, *args) -> None:
        """
        Helper method to append values to the output bytecode list.

        :param args: Values to be appended to the bytecode list.
        :return: None
        """
        for i in args:
            self._outputCodeList.append(i)


    def _initCode(self) -> None:
        """
        Initialize the code generation process by cleaning up and preparing the input code.

        :return: None
        """
        # Remove white spaces around lines
        for i, v in enumerate(self._inpCodeList):
            self._inpCodeList[i] = v.strip()

        # Remove blank lines
        while '' in self._inpCodeList:
            self._inpCodeList.remove('')

        # Add magic number for Locks VM
        self._emit(0x4d, 0x69, 0x68, 0x6f)

    #
    # Converts identifiers to indices and labels to memory locations
    # Also counts the number of functions and the code size for each one
    #
    def _resolveLabels(self) -> None:
        """
        Resolve labels, convert identifiers to indices, and count functions and their code sizes.

        :return: None
        """

        # Count functions and store their indices
        i = 0
        while i < len(self._inpCodeList):
            # Split the line by spaces
            l = self._inpCodeList[i].split(' ')

            # Check if the line starts with 'fn' (function declaration)
            if l[0] == "fn":
                # Store the function name and its corresponding index
                self._fnDict[l[1]] = self._fnCount
                # Remove the line from the input code list
                self._inpCodeList.pop(i)
                # Increment the function count
                self._fnCount += 1

            i += 1

        # Process input code to resolve labels and calculate total instruction size
        i = 0
        totalInsSize = 0

        while i < len(self._inpCodeList):
            # Split the line by spaces
            l = self._inpCodeList[i].split(' ')

            # 'argc' marks the beginning of a function
            if l[0] == "argc":
                # Reset the total instruction size for a new function
                totalInsSize = 0

            elif l[0][0] == '.':
                # Labels are marked with '.' and stored in the labels dictionary
                self._labelsDict[l[0][1:]] = totalInsSize
                # Remove the line from the input code list
                self._inpCodeList.pop(i)
                continue

            else:
                # Calculate the size of the opcode and add to total instruction size
                if l[0] in opcodeSizeDict:
                    totalInsSize += opcodeSizeDict[l[0]]

            i += 1

    def _removeFromFront(self, n: int) -> None:
        """
        Remove the first n lines from the input code list.

        :param n: Number of lines to remove from the front.
        :return: None
        """
        self._inpCodeList = self._inpCodeList[n:]

    def _makeConstantPool(self) -> None:
        """
        Generate the constant pool in the bytecode.

        :return: None
        """
        # cpc - constants pool size
        size: int = int(self._inpCodeList[0].split(' ')[1])

        # Emit the size of the constants pool in the bytecode
        self._emit(
            (size & 0xff00) >> 8,
            (size & 0xff)
        )

        # Remove the line containing the constants pool size
        self._removeFromFront(1)

        # Process each constant in the constant pool
        for i in range(size):
            typ: str = self._inpCodeList[i][0]
            ins: List[str] = self._inpCodeList[i][1:].strip()
            
            if typ == 'i':
                # Integer constant
                self._makeInteger(int(ins))

            elif typ == 'd':
                # Double constant
                self._makeDouble(float(ins))

            elif typ == 's':
                # String constant
                self._makeString(ins[1:-1])

        # Remove processed constants from the input code list
        self._removeFromFront(size)

    def _makeInteger(self, i: int) -> None:
        """
        Generate bytecode for an integer constant.

        :param i: The integer value to be represented in bytecode.
        :return: None
        """

        # Emit the integer tag (0x03) to indicate an integer constant
        self._emit(0x03)

        # Two's complement representation for negative integers
        if i < 0:
            i = -i
            # Flip bits by using XOR with all 1s and then add 1
            i = i ^ (0xffffffffffffffff)
            i += 1

        # Split the integer into 8 bytes and emit them in little-endian order
        self._emit(
            (i & 0xff00000000000000) >> 56,
            (i & 0xff000000000000) >> 48,
            (i & 0xff0000000000) >> 40,
            (i & 0xff00000000) >> 32,
            (i & 0xff000000) >> 24,
            (i & 0xff0000) >> 16,
            (i & 0xff00) >> 8,
            i & 0xff,
        )
    def _makeDouble(self, d: float) -> None:
        # Emit the tag for double (0x06)
        self._emit(0x06)  

        # Check the sign of the floating-point number
        sign: int = 0
        if d < 0:
            sign = 1
            d = -d

        # Calculate the exponent and mantissa for the floating-point number
        exp: int = len(str(d)[str(d).index('.')+1:])
        mantissa: int = int(d*10**exp)

        # Create a 64-bit integer representation of the floating-point number
        i = (sign << 63) + (exp << 52) + (mantissa)

        # Split the 64-bit integer into 8 bytes and emit each byte
        self._emit(
            (i & 0xff00000000000000) >> 56,
            (i & 0xff000000000000) >> 48,
            (i & 0xff0000000000) >> 40,
            (i & 0xff00000000) >> 32,
            (i & 0xff000000) >> 24,
            (i & 0xff0000) >> 16,
            (i & 0xff00) >> 8,
            i & 0xff,
        )


    def _makeString(self, s: str) -> None:
        # Emit the tag for string (0x08)
        self._emit(0x08)  

        # Emit the ASCII values of each character in the string
        for c in s:
            self._emit(ord(c))

        # Emit the null terminator (0x00) to mark the end of the string
        self._emit(0x00)


    def _makeCode(self) -> None:
        # Emit the number of functions, split into two bytes
        self._emit(
            self._fnCount >> 8,
            self._fnCount & 0xff
        )

        # Iterate over the number of functions and call _makeFunction for each
        for _ in range(self._fnCount):
            self._makeFunction()


    def _makeFunction(self) -> None:
        """
        Generate bytecode for a function.

        This method processes the input code for a function, extracts relevant information such as the number
        of arguments (argc) and calculates the total size of the function in bytes based on the opcodes.

        :return: None
        """

        # Create an empty dictionary to store local variable names and their corresponding indices
        localVarDict: Dict[str, int] = dict()

        # Initialize the count of local variables
        localVarCount: int = 0

        # Extract the number of arguments (argc) from the first line of input code
        argc: int = int(self._inpCodeList[0].split(' ')[1])

        # Emit the argc value, splitting it into two bytes
        self._emit(
            argc >> 8,
            argc & 0xff
        )

        # Remove the first line from the input code list
        self._removeFromFront(1)

        # Calculate the total function size in bytes based on the opcodes in the input code
        size: int = 0
        for l in self._inpCodeList:
            # Extract the opcode from each line and ignore additional information
            l = l.split(' ')[0]

            # Check if the opcode is "argc," indicating the end of the function definition
            if l == "argc":
                break

            # Retrieve the size of the opcode from the opcodeSizeDict (assumed to be defined elsewhere)
            size += opcodeSizeDict[l]

        # Emit the total function size, splitting it into two bytes
        self._emit(
            size >> 8,
            size & 0xff
        )
        
        while len(self._inpCodeList) > 0:
            # Split the instruction into opcode and arguments
            ins = self._inpCodeList[0].split(' ')

            # "argc" marks the beginning of a new function
            if ins[0] == "argc":
                # Exit the loop when encountering the start of a new function
                break

            # Emit the bytecode for the opcode using the opcodeNameDict
            self._emit(opcodeNameDict[ins[0]])

            # Calculate the number of arguments for the current opcode
            argc = opcodeSizeDict[ins[0]] - 1

            # Handle non-numeric arguments for certain opcodes
            if argc > 0 and not ins[1].isnumeric():
                # Replace labels or function names with their corresponding values
                if ins[1] in self._labelsDict:
                    ins[1] = self._labelsDict[ins[1]]
                elif ins[1] in self._fnDict:
                    ins[1] = self._fnDict[ins[1]]

            # Handle local and global variable instructions
            if ins[0] in ["STORE_LOCAL", "LOAD_LOCAL", "STORE_GLOBAL", "LOAD_GLOBAL"]:
                # Track local variables and assign indices if not already in localVarDict
                if ins[1] not in localVarDict:
                    localVarDict[ins[1]] = localVarCount
                    ins[1] = localVarCount
                    localVarCount += 1
                else:
                    ins[1] = localVarDict[ins[1]]

            # Emit arguments based on the number of arguments
            if argc == 1:
                # For a single argument, emit the argument value
                arg: int = int(ins[1])
                self._emit(arg)
            elif argc == 2:
                # For two arguments, emit them as two bytes
                arg: int = int(ins[1])
                self._emit(
                    arg >> 8,
                    arg & 0xff
                )

            # Remove the processed instruction from the input code list
            self._removeFromFront(1)
