# Import necessary modules
import sys  # System-specific parameters and functions
import argparse  # Parser for command-line options, arguments, and sub-commands
import os  # Miscellaneous operating system interfaces
import tkinter as tk  # Python's standard GUI (Graphical User Interface) package
from time import time  # Time-related functions

# Import modules from the loks package
from loks.lexerOrScanner.lexer import Lexer  # Lexer for tokenizing source code
from loks.parser.parser import Parser  # Parser for creating an Abstract Syntax Tree (AST)
from loks.analyser.analyser import SemanticAnalyzer  # Semantic analyzer for checking semantic errors
from loks.interpreter.interpreter import Interpeter  # Interpreter for executing Loks programming language code

from loks.compiler.compiler import Compiler  # Compiler for translating Loks code to bytecode
from loks.assembler.assembler import Assembler  # Assembler for converting bytecode to machine code
from loks.vm.vm import VirtualMachine  # Virtual Machine for executing machine code

from loks.error import Error  # Custom error classes for handling exceptions

from loks.visualizeAST.gendot import VisualizeAST  # AST visualization tool

# Import the argparse module for handling command-line arguments
import argparse

# Define the main function of the program
def main():
    # Setup CLI by creating an ArgumentParser object with a program description
    argParser = argparse.ArgumentParser(
        description="loks-py: the loks interpreter"
    )

    # Define a required positional argument for the path to a locks file
    argParser.add_argument(
        'path',
        metavar='path',
        type=str,
        help='path to a loks(.lks) file'
    )

    # Define an optional argument for enabling debugging mode
    argParser.add_argument(
        '-d',
        '--debug',
        action='store_true',
        help='Use the tree walk interpreter instead of the loks VM to execute code.',
    )

    # Define an optional argument for specifying an output file for bytecode
    argParser.add_argument(
        '-b',
        '--bytecode',
        metavar="<output-filename>",
        help='Store code generated by compiler in specified file.',
    )
    
    # Define a command-line argument for viewing bytecode
    argParser.add_argument(
        '-v',  # Short form of the argument
        '--viewBytecode',  # Long form of the argument
        action='store_true',  # Set to True if the argument is present, indicating a boolean flag
        help='Output code generated by compiler to stdout.'  # Help message explaining the purpose of the argument
    )

    # Define a command-line argument for generating AST dot file
    argParser.add_argument(
        '-g',  # Short form of the argument
        '--genASTdot',  # Long form of the argument
        metavar="<output-filename>",  # Placeholder for the argument value in the help message
        help='Generate a graphviz dot file to visualize AST. Generated code will be stored in specified file.'  # Help message explaining the purpose of the argument
    )

    # Parse the command-line arguments using the ArgumentParser
    args = argParser.parse_args()

    # Attempt to open and read the specified file
    try:
        program = open(args.path, 'r', encoding='unicode_escape').read()
    except FileNotFoundError:
        # Handle the case where the file is not found and provide a meaningful error message
        print(f"Error: file '{args.path}' not found")
        return 1
    except Exception as e:
        # Handle other exceptions that might occur while opening the file
        print(f"Error opening file '{args.path}'")
        print(f"Error: {e}")
        return 1

    # Tokenize the program using a Lexer
    l = Lexer(program)
    tokl = l.getTokens()

    # Check if the lexer encountered errors during tokenization
    if l.hadError:
        # Print each lexer error message
        for e in l.getErrorList():
            print(e)

        # Optionally wait for user input if in debug mode
        if args.debug:
            input("\nPress Enter to continue...")

        # Return a non-zero value to indicate an error occurred during tokenization
        return -1
    # Parser - construct Abstract Syntax Tree (AST) from the token list
    p = Parser(tokl)
    ast = p.getAST()

    # Check if errors occurred during parsing
    if p.hadError:
        # Print each parser error message
        for i in p.getError():
            print(i)

        # Optionally wait for user input if in debug mode
        if args.debug:
            input("\nPress Enter to continue...")

        # Return a non-zero value to indicate an error occurred during parsing
        return -1

    # Visualize AST if specified by the command-line argument
    if args.genASTdot:
        # Initialize VisualizeAST class to create a Graphviz dot file
        vis = VisualizeAST()
        
        # Visit the AST to populate the visualization data
        vis.visit(ast)
        
        # Get the Graphviz dot code
        dot = vis.getDot()

        # Attempt to open and write to the specified dot file
        try:
            f = open(args.genASTdot, 'w')
        except (IsADirectoryError, NotADirectoryError):
            # Handle directory-related errors
            print("Please enter a valid filename or a path to a file. Note that if the file is in a subdirectory, the subdirectory must already exist. If the specified file does not exist, it will be created.")
            input("\nPress Enter to continue...")
            return -1
        except Exception as e:
            # Handle other file-related errors
            print(f"Unable to open '{args.genASTdot}'. Please enter a valid filename or make sure that the script has enough permissions.")
            print(f"Error: {e}")
            input("\nPress Enter to continue...")
            return -1

        # Attempt to import the 'requests' module for online visualization
        try:
            import requests
        except ModuleNotFoundError:
            # If 'requests' module is not found, write the dot file locally
            f.write(dot)
            f.close()
            print(f"'requests' module was not installed or found. A dot file was written to {args.genASTdot}. Install the requests module with 'pip install requests', or visit https://github.com/L1M1N4L for more information.")
            input("\nPress Enter to continue...")
            return -1
        except Exception as e:
            # Handle unexpected errors during 'requests' module import
            f.write(dot)
            f.close()
            print(f"An unexpected error occurred when importing the 'requests' module. A dot file was written to {args.genASTdot}. For more information, visit  https://github.com/L1M1N4L.")
            print(f"Error: {e}")
            input("\nPress Enter to continue...")
            return -1
        finally:
            # Write the dot file and close it in the 'finally' block to ensure it is closed regardless of exceptions
            f.write(dot)
            f.close()

        # Open an SVG file for writing in the same directory as the original dot file
        f = open(f"{os.path.dirname(args.genASTdot)}/{os.path.basename(args.genASTdot)}.svg", 'w')

        # Attempt to render the dot file as an SVG using an online service
        try:
            # Notify the user about the ongoing process
            print("Working on it...\n")
            
            # Use requests to get the SVG from the online service
            r = requests.get(f'https://quickchart.io/graphviz?&graph={requests.utils.quote(dot)}', timeout=15)
        except (requests.ConnectionError, requests.Timeout):
            # Handle connection or timeout errors during the request
            print(f"Unable to render {args.genASTdot}. Either there is no internet connection, or the generated dot file was too large (> 2048 characters). Visit  https://github.com/L1M1N4L for more information about how to render the generated dot file.\n")
            input("\nPress Enter to continue...")
            return -1

        # Write the received SVG content to the SVG file
        f.write(r.text)
        f.close()

            # Attempt to import the 'cairosvg' module for SVG to PNG conversion
        try:
            import cairosvg
        except ModuleNotFoundError:
            # Handle the case where 'cairosvg' module is not found
            print(f"'cairosvg' module was not installed or found. An SVG file was written to {os.path.dirname(args.genASTdot)}/{os.path.basename(args.genASTdot)}.svg. You can open this SVG file to view the image generated from the AST. For more information, visit  https://github.com/L1M1N4L.")
            input("\nPress Enter to continue...")
            return -1
        except Exception as e:
            # Handle unexpected errors during 'cairosvg' module import
            print(f"An unexpected error occurred when importing the 'cairosvg' module. An SVG file was written to {os.path.dirname(args.genASTdot)}/{os.path.basename(args.genASTdot)}.svg. You can open this SVG file to view the image generated from the AST. For more information, visit  https://github.com/L1M1N4L.")
            print(f"Error: {e}")
            input("\nPress Enter to continue...")
            return -1

        # Attempt to convert the SVG file to PNG using cairosvg
        try:
            cairosvg.svg2png(
                url=f'{os.path.dirname(args.genASTdot)}/{os.path.basename(args.genASTdot)}.svg', 
                write_to=f"{os.path.dirname(args.genASTdot)}/{os.path.basename(args.genASTdot)}.png",
                scale=0.5
            )
        except Exception as e:
            # Handle unexpected errors during SVG to PNG conversion
            print(f"An unexpected error occurred while converting {args.genASTdot} to SVG. Visit  https://github.com/L1M1N4L for more information about how to render the generated dot file. If the dot file doesn't render correctly, open an issue.\n")
            print(f"Error: {e}")
            input("\nPress Enter to continue...")
            return -1


        # Attempt to import the 'Pillow' module for image display
        try:
            from PIL import Image, ImageTk
        except ModuleNotFoundError:
            # Handle the case where 'Pillow' module is not found
            print(f"'Pillow' module was not installed or found. A PNG file was written to {os.path.dirname(args.genASTdot)}/{os.path.basename(args.genASTdot)}.png. You can open this PNG file to view the image generated from the AST. For more information, visit  https://github.com/L1M1N4L.")
            input("\nPress Enter to continue...")
            return -1
        except Exception as e:
            # Handle unexpected errors during 'Pillow' module import
            print(f"An unexpected error occurred when importing the 'Pillow' module. A PNG file was written to {os.path.dirname(args.genASTdot)}/{os.path.basename(args.genASTdot)}.png. You can open this PNG file to view the image generated from the AST. For more information, visit  https://github.com/L1M1N4L.")
            print(f"Error: {e}")
            input("\nPress Enter to continue...")
            return -1

        # Create a Tkinter window for displaying the image
        wnd = tk.Tk()

        # Open the PNG image using Pillow
        img = Image.open(f'{os.path.dirname(args.genASTdot)}/{os.path.basename(args.genASTdot)}.png')

        # Convert the image to a Tkinter-compatible format
        pimg = ImageTk.PhotoImage(img)

        # Get the size of the image
        size = img.size

        # Create a canvas in the Tkinter window and display the image
        frame = tk.Canvas(wnd, width=size[0], height=size[1])
        frame.pack()
        frame.create_image(0, 0, anchor='nw', image=pimg)

        # Provide instructions to the user on how to view the complete image if it doesn't fit in the window
        print(f"\nIf the complete image doesn't fit in the window, try opening it with an external image viewer. The image was saved at '{os.path.dirname(args.genASTdot)}/{os.path.basename(args.genASTdot)}.png'.\n")

        # Run the Tkinter main loop
        wnd.mainloop()

        # Wait for user input before continuing
        input("\nPress Enter to continue...")

        # Return 0 to indicate successful execution
        return 0

    # Semantic Analyzer - check AST for static semantic errors
    s = SemanticAnalyzer()
    s.visit(ast)

    # Check if static semantic errors were found during analysis
    if s.hadError:
        # Print each static semantic error message
        for e in s.getErrorList():
            print(e)

        # Optionally wait for user input if in debug mode
        if args.debug:
            input("\nPress Enter to continue...")

        # Return a non-zero value to indicate static semantic errors
        return -1

    # Check if the user specified the '-b' flag to output generated code
    if args.bytecode:
        # Generate bytecode using the Compiler class
        c = Compiler()
        c.visit(ast)
        code = c.getCode()

        # Write the generated code to the specified file
        outputf = open(args.bytecode, "w")
        outputf.write(code)
        outputf.close()

        # Return 0 to indicate successful code generation
        return 0

    # Check if the user specified the '-v' flag to view the generated bytecode
    if args.viewBytecode:
        # Generate and print the bytecode using the Compiler class
        c = Compiler()
        c.visit(ast)
        print(c.getCode())

        # Return 0 to indicate successful code generation
        return 0

 # -d specified, use tree walk interpreter
    if args.debug:
        try:
            t0 = time()

            i = Interpeter()
            i.visit(ast)

            print(f"\nProcess finished in {time() - t0} seconds with return code 0")
            input("Press Enter to continue...")
        except KeyboardInterrupt:
            print("\nKeyboard Interrupt")

            print(f"\nProcess finished in {time() - t0} seconds with return code -1")
            input("Press Enter to continue...")

            return -1
        except Error as e:
            print(e)

            print(f"\nProcess finished in {time() - t0} seconds with return code -1")
            input("Press Enter to continue...")

            return -1
        except:
            print("The interpreter crashed! Check the Known Bugs sections in the Loks github repository (https://github.com/L1M1N4L) or open an issue.")
            return -1

        # Check if debug mode is not enabled
        else:
            try:
                # Attempt to compile the AST using the Compiler class
                c = Compiler()
                c.visit(ast)
                code = c.getCode()
            except:
                # Handle compilation errors and print an error message
                print("\nCompile Error. Exiting...")
                return -1

            try:
                # Attempt to assemble the generated code using the Assembler class
                a = Assembler(code)
                b = a.getBytecodeList()

                # Create and run the Virtual Machine with the assembled bytecode
                v = VirtualMachine(b)
                v.run()
            except Error as e:
                # Handle runtime errors and print an error message
                print(e)
                return -1

        # Return 0 to indicate successful execution
        return 0


if __name__ == '__main__':
    main()